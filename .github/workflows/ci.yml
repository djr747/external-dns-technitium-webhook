name: CI

on:
  push:
    branches:
      - '**'
      - '!main'
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write
  packages: write
  id-token: write

jobs:
  lint:
    name: Lint and Format Check (Python)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Run Ruff format check
        run: ruff format --check .

      - name: Run Ruff lint
        run: ruff check .

      - name: Run mypy
        run: mypy external_dns_technitium_webhook

      - name: Run pyright
        run: pyright

  test:
    name: Unit Test (Python)
    runs-on: ubuntu-latest
    needs: [lint]
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.13']

    steps:
      - uses: actions/checkout@v5

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Run tests with coverage
        run: |
          pytest tests/unit/ --cov=external_dns_technitium_webhook --cov-report=xml --cov-report=html --cov-report=term-missing --cov-fail-under=95

      - name: Upload coverage report
        uses: actions/upload-artifact@v5
        with:
          name: coverage-report
          path: htmlcov/
          retention-days: 30

  build-amd64:
    name: Build Docker Image (amd64)
    runs-on: ubuntu-latest
    needs: [test]
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Generate image tag
        id: image-tag
        run: |
          COMMIT_SHA=${{ github.sha }}
          IMAGE_TAG="external-dns-technitium-webhook:${COMMIT_SHA:0:7}"
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for amd64
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          load: true
          tags: ${{ steps.image-tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify built image Python version matches Chainguard latest
        run: |
          echo "Checking Python version inside built image..."
          chainguard_version=$(docker run --rm --entrypoint python cgr.dev/chainguard/python:latest -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          image_version=$(docker run --rm --entrypoint python ${{ steps.image-tag.outputs.tag }} -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          if [ "$image_version" != "$chainguard_version" ]; then
            echo "ERROR: Python version in built image ($image_version) does not match Chainguard latest ($chainguard_version)"
            exit 1
          fi
          echo "Python version in built image matches Chainguard latest: $image_version"

      - name: Save Docker image to artifact
        run: |
          docker save ${{ steps.image-tag.outputs.tag }} -o /tmp/webhook-image.tar
          
      - name: Upload image artifact
        uses: actions/upload-artifact@v5
        with:
          name: webhook-image-amd64
          path: /tmp/webhook-image.tar
          retention-days: 1

  build-arm64:
    name: Build Docker Image (arm64)
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for arm64
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/arm64
          push: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
          sbom: true
          provenance: true

  integration:
    name: Integration Tests (Kubernetes)
    runs-on: ubuntu-latest
    needs: [build-amd64, build-arm64]
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download webhook image
        uses: actions/download-artifact@v5
        with:
          name: webhook-image-amd64
          path: /tmp

      - name: Load webhook image
        run: |
          docker load -i /tmp/webhook-image.tar

      - name: Create Kind cluster config
        run: |
          cat > /tmp/kind-config.yaml <<EOF
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
            - role: control-plane
              extraPortMappings:
                - containerPort: 5380
                  hostPort: 5380
                  protocol: TCP
                - containerPort: 53
                  hostPort: 5353
                  protocol: UDP
          EOF

      - name: Set up Kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: integration-test
          config: /tmp/kind-config.yaml
          version: v0.30.0
          kubectl_version: v1.33.4

      - name: Load webhook image into Kind
        run: |
          kind load docker-image ${{ needs.build-amd64.outputs.image-tag }} --name integration-test

      - name: Pull and load Technitium image into Kind
        run: |
          docker pull technitium/dns-server:latest
          kind load docker-image technitium/dns-server:latest --name integration-test

      - name: Generate test credentials
        id: creds
        run: |
          PASSWORD=$(openssl rand -base64 12)
          echo "admin_password=$PASSWORD" >> $GITHUB_OUTPUT

      - name: Create Technitium secret
        run: |
          kubectl create secret generic technitium-secret \
            --from-literal=username=admin \
            --from-literal=password=${{ steps.creds.outputs.admin_password }} \
            -n default

      - name: Deploy Technitium DNS
        run: |
          kubectl apply -f tests/integration/k8s/technitium-deployment.yaml

      - name: Wait for Technitium deployment
        run: |
          kubectl wait --for=condition=ready pod \
            -l app=technitium \
            --timeout=300s \
            -n default

      - name: Run Technitium initialization script
        id: init
        run: |
          kubectl run technitium-init \
            --image=curlimages/curl:latest \
            --restart=Never \
            --attach=true \
            --quiet \
            --env="TECHNITIUM_URL=http://technitium:5380" \
            --env="ADMIN_PASSWORD=${{ steps.creds.outputs.admin_password }}" \
            --env="CATALOG_ZONE=catalog.invalid" \
            -- sh -c "$(cat tests/integration/fixtures/init-technitium.sh)"
          
          # Get logs and capture credentials
          echo ""
          echo "=== Technitium Init Pod Logs ==="
          INIT_LOGS=$(kubectl logs technitium-init -n default 2>&1 || true)
          echo "$INIT_LOGS"
          
          # Extract credentials from logs
          TECH_USERNAME=$(echo "$INIT_LOGS" | grep "^TECHNITIUM_USERNAME=" | cut -d= -f2)
          TECH_PASSWORD=$(echo "$INIT_LOGS" | grep "^TECHNITIUM_PASSWORD=" | cut -d= -f2)
          TECH_ZONE=$(echo "$INIT_LOGS" | grep "^TECHNITIUM_ZONE=" | cut -d= -f2)
          
          echo "technitium_username=$TECH_USERNAME" >> $GITHUB_OUTPUT
          echo "technitium_password=$TECH_PASSWORD" >> $GITHUB_OUTPUT
          echo "technitium_zone=$TECH_ZONE" >> $GITHUB_OUTPUT
          
          # Clean up the pod - force delete if needed
          kubectl delete pod technitium-init -n default --force --grace-period=0 2>/dev/null || true
          
          # Check if initialization succeeded by verifying outputs
          if [ -z "$TECH_PASSWORD" ] || [ -z "$TECH_USERNAME" ]; then
            echo ""
            echo "ERROR: Technitium initialization failed - could not extract credentials"
            exit 1
          fi

      - name: Add External DNS Helm repository
        run: |
          helm repo add external-dns https://kubernetes-sigs.github.io/external-dns/
          helm repo update

      - name: Deploy External DNS with webhook
        run: |
          # The build step emits an image reference like "external-dns-technitium-webhook:d244611"
          # Split that into repository and tag and pass them separately to Helm so we don't
          # end up with a malformed image name (repo:repo:tag)
          FULL_IMAGE="${{ needs.build-amd64.outputs.image-tag }}"
          REPO="${FULL_IMAGE%:*}"
          TAG="${FULL_IMAGE##*:}"

          echo "Using image repository: $REPO"
          echo "Using image tag: $TAG"

            helm install external-dns external-dns/external-dns \
            -f tests/integration/helm/external-dns-values.yaml \
            --set provider.webhook.image.repository="${REPO}" \
            --set provider.webhook.image.tag="${TAG}" \
            -n default \
            --timeout=5m

      - name: Wait for External DNS deployment (loop with event logging)
        run: |
          set -x
          set +e
          echo "Waiting for ExternalDNS pod to become ready (max 160s)..."

          for i in $(seq 1 8); do
            POD=$(kubectl get pods -n default -l app.kubernetes.io/name=external-dns -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
            STATUS=$(kubectl get pods -n default -l app.kubernetes.io/name=external-dns -o jsonpath='{.items[0].status.phase}' 2>/dev/null)
            CONTAINER_STATUSES=$(kubectl get pods $POD -n default -o json | jq -r '.status.containerStatuses[] | "\(.name):ready=\(.ready),state=\(.state),reason=\(.lastState.terminated.reason // .state.waiting.reason // .state.running.reason // \"\")"')
            echo "[${i}/8] Pod: $POD status: $STATUS"
            echo "$CONTAINER_STATUSES"
            kubectl get pods -n default -l app.kubernetes.io/name=external-dns
            kubectl describe pod $POD -n default || true
            kubectl get events -n default --sort-by=.lastTimestamp | grep external-dns || true
            echo "--- ExternalDNS container logs (current) ---"
            kubectl logs $POD -c external-dns -n default --tail=50 || true
            echo "--- Webhook-provider container logs (current) ---"
            kubectl logs $POD -c webhook-provider -n default --tail=50 || true
            # If either container is in CrashLoopBackOff, print and exit
            if echo "$CONTAINER_STATUSES" | grep -q 'CrashLoopBackOff'; then
              echo "ERROR: At least one container is in CrashLoopBackOff."
              exit 1
            fi
            # If both containers are ready, continue
            READY_EXTERNAL=$(echo "$CONTAINER_STATUSES" | grep '^external-dns:' | grep -q 'ready=true' && echo true || echo false)
            READY_WEBHOOK=$(echo "$CONTAINER_STATUSES" | grep '^webhook-provider:' | grep -q 'ready=true' && echo true || echo false)
            if [ "$READY_EXTERNAL" = "true" ] && [ "$READY_WEBHOOK" = "true" ]; then
              echo "Both containers are ready!"
              exit 0
            fi
            sleep 20
          done
          echo "ERROR: ExternalDNS pod did not become ready after 160s."
          exit 1

      - name: Check External DNS pod status
        run: |
          kubectl get pods -n default
          kubectl describe pod -l app.kubernetes.io/name=external-dns -n default || true
          kubectl logs -l app.kubernetes.io/name=external-dns -n default --tail=50 || true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Install integration test dependencies
        run: |
          pip install pytest pytest-asyncio httpx kubernetes

      - name: Run integration tests
        env:
          TECHNITIUM_URL: http://localhost:5380
          WEBHOOK_URL: http://localhost:8888
        run: |
          pytest tests/integration/test_webhook_integration.py \
            -v \
            --tb=short \
            -m ""

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Kubernetes Pods ==="
          kubectl get pods -n default
          
          echo ""
          echo "=== Technitium Logs ==="
          kubectl logs -l app=technitium -n default --tail=100 || true
          
          echo ""
          echo "=== External DNS Logs ==="
          kubectl logs -l app.kubernetes.io/name=external-dns -n default --tail=100 || true
          
          echo ""
          echo "=== Webhook Sidecar Logs ==="
          kubectl logs -l app.kubernetes.io/name=external-dns -n default -c webhook-provider --tail=100 || true

      - name: Cleanup Kind cluster
        if: always()
        run: |
          kind delete cluster --name integration-test

  push:
    name: Push Docker Image to Registry
    runs-on: ubuntu-latest
    needs: [build-amd64, integration, build-arm64]
    if: success()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download webhook image
        uses: actions/download-artifact@v5
        with:
          name: webhook-image-amd64
          path: /tmp

      - name: Load webhook image
        run: |
          docker load -i /tmp/webhook-image.tar

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=commit-
            type=raw,value=ci-${{ github.sha }},enable={{is_default_branch}}

      - name: Push Docker image to registry
        run: |
          for tag in ${{ steps.meta.outputs.tags }}; do
            docker tag ${{ needs.build-amd64.outputs.image-tag }} "$tag"
            docker push "$tag"
          done
